import "./blocks";

import { Lua, Blocks, Block, FieldTextInput, FieldDropdown, Workspace, Events } from "blockly/core";

function generateObjectCode(type: string, block: Block): string {
    const name = block.getFieldValue("NAME");

    const dsc = Lua.valueToCode(block, "DSC", Lua.ORDER_NONE);

    let code = type + " {\n"
        + Lua.INDENT + "nam = " + Lua.quote_(name) + ",\n";

    if (dsc) {
        code += Lua.prefixLines("dsc = " + dsc, Lua.INDENT);
    }

    // Blocks in definition need to be comma-separated.
    let needNL = false;
    for (let defBlock = block.getInputTargetBlock("DEFINITION"); defBlock; defBlock = defBlock.getNextBlock()) {
        const defCode = Lua.blockToCode(defBlock, true);
        if (typeof defCode !== "string") {
            throw TypeError("Expecting code from statement block: " +
                (defBlock && defBlock.type));
        }
        if (defCode) {
            needNL = true;
            code += ",\n" + Lua.prefixLines(defCode, Lua.INDENT);
        }
    }

    if (needNL) {
        code += "\n";
    }

    code += "}";

    return code;
}

function addStandardFields(type: string, block: Block): Block {
    block.appendDummyInput()
        .appendField(type)
        .appendField(new FieldTextInput(type), "NAME")
    block.appendValueInput("DSC")
        .appendField("Описание(dsc): ")
        .setCheck("String");

    block.appendStatementInput("DEFINITION");
    return block;
}

export const InsteadObject = {
    // There should be an empty element if no objects created
    // to prevent Blockly complaining that dropdown field should
    // have at least one option.
    objectsList: [["", ""]] as string[][],

    init: function (this: Block) {
        addStandardFields("Объект", this);
    },

    objectLifecycleListener: function (event: any) {
        if (!event.recordUndo) {
            // Events not generated by user. Skip handling.
            return;
        }

        const ws = event.getEventWorkspace_() as Workspace;
        if (event.type === Events.BLOCK_CREATE) {
            const block = ws.getBlockById(event.blockId);
            if (block.type !== "instead_object")
                return;
            InsteadObject.addInsteadObject(event.blockId, block.getFieldValue("NAME"));
            InsteadObject.refreshReferences(ws, block.id);
        } else if (event.type === Events.BLOCK_DELETE) {
            // There is no way to determine which type of block
            // was removed, so rely only on block id being in the list.
            InsteadObject.removeInsteadObject(event.blockId, ws);
        } else if (event.type === Events.BLOCK_CHANGE) {
            if (event.element !== "field" || event.name !== "NAME")
                return;
            const block = ws.getBlockById(event.blockId);
            if (block.type !== "instead_object")
                return;

            const idx = InsteadObject.findInsteadObject(event.blockId, true);
            InsteadObject.objectsList[idx][0] = block.getFieldValue("NAME");
            InsteadObject.refreshReferences(ws, block.id);
        }
    },

    addInsteadObject: function (blockId: string, name: string) {
        const idx = InsteadObject.findInsteadObject(blockId, false);
        if (idx >= 0) {
            // If object was added during deserialization, name is empty.
            // Fix it after workspace is loaded
            if (!InsteadObject.objectsList[idx][0])
                InsteadObject.objectsList[idx][0] = name;
            return;
        }

        if (InsteadObject.objectsList.length === 1 && !InsteadObject.objectsList[0][1]) {
            InsteadObject.objectsList.pop();
        }
        InsteadObject.objectsList.push([name, blockId]);
    },

    removeInsteadObject: function (blockId: string, ws: Workspace) {
        const idx = InsteadObject.findInsteadObject(blockId, false);

        if (idx < 0)
            return;

        InsteadObject.objectsList.splice(idx, 1);

        if (InsteadObject.objectsList.length === 0) {
            InsteadObject.objectsList.push(["", ""]);
        }

        // Remove dangling references
        const blocks = ws.getBlocksByType("instead_object_ref", false);
        blocks.forEach((block) => {
            const refName = block.getFieldValue("NAME");
            if (refName === blockId) {
                block.dispose(true);
            }
        });
    },

    findInsteadObject: function (id: string, required: boolean): number {
        const idx = InsteadObject.objectsList.findIndex((arr) => { return arr[1] === id });
        if (required && idx < 0)
            throw TypeError("Object with id " + id + " not found");
        return idx;
    },

    getInsteadObjectName: function (id: string): string {
        const idx = InsteadObject.findInsteadObject(id, true);
        return InsteadObject.objectsList[idx][0];
    },

    refreshReferences: function (ws: Workspace, id: string) {
        const blocks = ws.getBlocksByType("instead_object_ref", false);
        blocks.forEach((block) => {
            const field = block.getField("NAME");
            if (field.getValue() === id) {
                field.forceRerender();
            }
        });
    }
};

Blocks["instead_object"] = InsteadObject;
Lua["instead_object"] = function (block: Block) {
    return generateObjectCode("obj", block);
};

Blocks["instead_room"] = {
    init: function (this: Block) {
        addStandardFields("Комната", this);
    }
};

Lua["instead_room"] = function (block: Block) {
    return generateObjectCode("room", block);
};

// TODO: Maybe have a separate object "Main room" where nam overridden into "main" and disp used instead.
// Or maybe just provide it as a "default" workspace, since disp is useful for dynamic title.

class ObjectReferenceDropDown extends FieldDropdown {
    constructor() {
        super(InsteadObject.objectsList);
    }
    // Override deserialization to temporarily add value into the
    // list so validation passes. Real object should come soon.
    fromXml(fieldElement: Element): void {
        const value = fieldElement.textContent as string;
        InsteadObject.addInsteadObject(value, "");
        this.setValue(value);
    }
}

Blocks["instead_object_ref"] = {
    init: function (this: Block) {
        this.appendDummyInput()
            .appendField(new ObjectReferenceDropDown(), "NAME");
        this.setOutput(true, ["InsteadObject"]);
    },
};

Lua["instead_object_ref"] = function (block: Block) {
    return ["_\"" + InsteadObject.getInsteadObjectName(block.getFieldValue("NAME")) + "\"", Lua.ORDER_ATOMIC]
}
